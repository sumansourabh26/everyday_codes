#lang racket
(require plot)
(plot-new-window? #t)
(plot-width 900)
(plot-height 900)
(define (draw curve)
  (plot (parametric
         (λ (t) (let* ([ct (curve t)])
                  (vector (x-of ct)
                          (y-of ct))))
         0 1 #:width 1 #:samples 20000
         #:x-min -1000 #:x-max  1000
         #:y-min -1000 #:y-max  1000)))
(define (compose f g)
  (λ (x)
    (f (g x))))
(define (thrice f)
  (compose (compose f f) f))
(define (identity x) x)
(define (repeated f n)
  (if (= n 0)
      identity
      (compose f (repeated f (- n 1)))))
(define (make-point x y)
  (λ (bit)
    (if (zero? bit) x y)))
(define (x-of point)
  (point 0))
(define (y-of point)
  (point 1))
(define (unit-circle t)
  (make-point (sin (* 2 pi t))
              (cos (* 2 pi t))))
(define (unit-line-at y)
  (λ (t) (make-point t y)))
(define unit-line (unit-line-at 0))
(define (rotate-pi/2 curve)
  (λ (t)
    (let ((ct (curve t)))
      (make-point
       (- (y-of ct))
       (x-of ct)))))
(define(sqrt-sqr x y)
  (sqrt(+(sqr x)(sqr y))))
(define((translate a b)curve)
  (λ(t)(let((ct (curve t)))
         (make-point (+ a ct) (+ b ct)))))
(define(scale rx ry)
  (λ(curve)
    (λ(t)(make-point (/  (x-of (curve t))rx)(/ (y-of (curve t))ry)))))
(define(put-in-standard-position curve)
  (λ(t)(let*((curve ((translate (* -1 (x-of (curve 0)))(* -1 (y-of (curve 0))))curve))
             (curve (cond[(and (= (x-of (curve 1)) 0)(> (y-of (curve 1)) 0)) (rotate-around-origin (/ pi 2) curve)]
                         [(and (= (x-of (curve 1)) 0)(< (y-of (curve 1)) 0)) (rotate-around-origin (-(/ pi 2))curve)]
                         [else(let ((slope (atan(/(y-of (curve 1))(x-of (curve 1))))))
                                (if (> (x-of (curve 1)) 0) ((rotate-around-origin slope) curve) (rotate-around-origin (+ pi slope) curve)))]))
             (curve ((scale ((sqrt-sqr (x-of (curve 1))(y-of (curve 1)))(sqrt-sqr (x-of (curve 1))(y-of (curve 1)))))curve)))
         (make-point (x-of (curve t))(y-of (curve t))))))
(define (str-line m c)
  (λ(t)
    (make-point t (+ c (* m t)))))
(define(semi-circle r)
  (λ(t)(make-point (* r (cos(* pi t))) (* r (sin(*  pi t))))))
(define((rotate-around-origin theta)curve)
  (λ(t)(let((ct (curve t)))
         (make-point (+(* (x-of ct)
                          (cos (- theta)))(* (y-of ct) 
                                             (sin (- theta))))(-(* (y-of ct)
                                                                   (cos (- theta)))(* (x-of ct)
                                                                                      (sin (- theta))))))))
(define (connect-rigidly curve1 curve2)
  (λ (t)
    (if (< t (/ 1 2))
        (curve1 (* 2 t))
        (curve2 (- (* 2 t) 1)))))
(define(connect-ends curve1 curve2)
  (let((c11 (curve1 1))
       (c20 (curve2 0)))
    (connect-rigidly curve1 ((translate (-(x-of c11)(x-of c20))
                                        (-(y-of c11)(y-of c20)))
                             curve2))))
(define (gosperize curve)
  (let ((scaled-curve ((scale  (sqrt 2) (sqrt 2) ) curve)))
    (connect-rigidly
     ((rotate-around-origin (/ pi 4)) scaled-curve)
     ((translate .5 .5)
      ((rotate-around-origin (/ (- pi) 4)) scaled-curve)))))
(define (gosper-curve level)
  ((repeated gosperize level) unit-line))
(define(square x y side)
  (λ(t)
    (cond[(> 0.25 t) (make-point x (+ y(* 4 t side)))] 
         [(> 0.5 t) (make-point (+ x(* 4 (- t 0.25)side)) (+ y side))]
         [(> 0.75 t) (make-point (+ x side)  (+ y(* side 4 (- 0.75 t))))]
         [else (make-point (+ x(* side 4(- 1 t))) y)])))
(define(horiline  length)
  (λ(t)
    (make-point (* t length) 0)))
(define(horilineopp  length)
  (λ(t)
    (make-point (* (- 1 t) length) 0)))
(define(verline  length)
  (λ(t)
    (make-point 0 (* t length))))
(define(verlineopp length)
  (λ(t)
    (make-point 0 (* (- 1 t) length))))

(define(cactus n)
  ((rotate-around-origin (/ pi 4))(cactush n (expt 3 n))))

(define(cactush n side)
  (if(= side 1) (square 0 0 side)
     (let ((fig (cactush (- n 1) (/ side 3))))
       (connect-ends
        (connect-rigidly
         (connect-rigidly
          (connect-ends 
           (horiline side) ((translate side 0) ((rotate-around-origin (- (/ pi 2)))fig )))
          ((translate side side) fig))
         ((translate 0 side) ((rotate-around-origin (/ pi 2))fig )))
        (verlineopp side)))))
(define(remain curve) 
       (let((remain-h ((scale  3 3) curve)))
         (connect-ends(connect-ends(connect-ends remain-h
                                                 ((rotate-around-origin (/ pi 3))remain-h))
                                   ((rotate-around-origin (-(/ pi 3)))remain-h))
                      remain-h)))
  (define(koch-flake level)
    (let ((third ((repeated remain level) unit-line)))
      (connect-ends(connect-ends third
                                 ((rotate-around-origin (-(/ (* 2 pi) 3)))third))
                   ((rotate-around-origin (/ (* 2 pi) 3))third))))
  